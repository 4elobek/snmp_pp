#include <doctest.h>

#include <vector>

#include "snmp_pp/vb.h"
#include "snmp_pp/snmpmsg.h"
#include "snmp_pp/snmperrs.h"

using namespace Snmp_pp;

namespace
{

const std::vector<unsigned char> TRAP_1{
    0x30, 0x6f, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa7, 0x62, 0x02,
    0x04, 0x5a, 0x4d, 0xb1, 0xfb, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x54, 0x30, 0x0f, 0x06,
    0x08, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x01, 0x03, 0x00, 0x43, 0x03, 0x1c, 0xb0, 0x63, 0x30, 0x16,
    0x06, 0x0a, 0x2b, 0x06, 0x01, 0x06, 0x03, 0x01, 0x01, 0x04, 0x01, 0x00, 0x06, 0x08, 0x2a, 0x03,
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x30, 0x17, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x01,
    0x06, 0x00, 0x04, 0x0b, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x53, 0x69, 0x6d, 0x6f, 0x6e, 0x30,
    0x10, 0x06, 0x08, 0x2a, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x04, 0x04, 0x64, 0x65, 0x76,
    0x31,
};

}

TEST_CASE("Raw trap data can be parsed.")
{
    Snmp_pp::SnmpMessage snmpmsg;
    snmpmsg.load(TRAP_1.data(), TRAP_1.size());

    Pdu pdu;
    OctetStr community_name;
    snmp_version version;
    int returncode = snmpmsg.unload(pdu, community_name, version);

    REQUIRE(returncode == SNMP_CLASS_SUCCESS);

    REQUIRE(community_name.get_printable() == std::string{"public"});
    REQUIRE(version == version2c);

    REQUIRE(!pdu.get_error_status());

    Snmp_pp::Oid id;
    REQUIRE(pdu.get_notify_id(id));
    REQUIRE(id.get_printable() == std::string{"1.2.3.4.5.6.7.8.9"});
    REQUIRE(pdu.get_type() == 167);

    Vb nextVb;

    using TrapContent = std::vector<std::pair<std::string, std::string>>;
    TrapContent content;
    for (int i=0; i<pdu.get_vb_count(); i++)
    {
        pdu.get_vb(nextVb, i);
        content.emplace_back(nextVb.get_printable_oid(), nextVb.get_printable_value());
    }

    REQUIRE(content == TrapContent{{"1.3.6.1.2.1.1.6.0", "Hello Simon"}, {"1.2.3.4.5.6.7.8.8", "dev1"}});
}